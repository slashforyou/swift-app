/**
 * Tests pour le hook useStaff
 * @jest-environment jsdom
 */

import { act, renderHook } from '@testing-library/react';
import { useStaff } from '../../src/hooks/useStaff';
import type { Contractor, Employee } from '../../src/types/staff';

// Mock data pour les tests
const mockEmployees: Employee[] = [
  {
    id: 'emp_1',
    type: 'employee',
    firstName: 'John',
    lastName: 'Doe',
    email: 'john@example.com',
    phone: '+61 400 000 000',
    role: 'Team Lead',
    team: 'Operations',
    startDate: '2023-01-01',
    status: 'active',
    tfn: '123456789',
    hourlyRate: 35,
    invitationStatus: 'completed',
    accountLinked: true,
  },
  {
    id: 'emp_2',
    type: 'employee',
    firstName: 'Jane',
    lastName: 'Smith',
    email: 'jane@example.com',
    phone: '+61 400 000 001',
    role: 'Mover',
    team: 'Operations',
    startDate: '2023-02-01',
    status: 'active',
    tfn: '987654321',
    hourlyRate: 30,
    invitationStatus: 'completed',
    accountLinked: true,
  }
];

const mockContractors: Contractor[] = [
  {
    id: 'con_1',
    type: 'contractor',
    firstName: 'Mike',
    lastName: 'Johnson',
    email: 'mike@contractor.com',
    phone: '+61 400 000 002',
    role: 'Specialized Mover',
    team: 'Operations',
    abn: '12 345 678 901',
    rate: 50,
    rateType: 'hourly',
    contractStatus: 'preferred',
    isVerified: true,
    startDate: '2024-01-01',
    status: 'active',
  }
];

describe('useStaff Hook', () => {
  describe('Initialization', () => {
    it('should initialize with default values', () => {
      const { result } = renderHook(() => useStaff());

      expect(result.current.staff).toEqual([]);
      expect(result.current.employees).toEqual([]);
      expect(result.current.contractors).toEqual([]);
      expect(result.current.isLoading).toBe(false);
      expect(result.current.error).toBe(null);
      expect(result.current.totalActive).toBe(0);
      expect(result.current.totalEmployees).toBe(0);
      expect(result.current.totalContractors).toBe(0);
    });

    it('should have all required functions', () => {
      const { result } = renderHook(() => useStaff());

      expect(typeof result.current.inviteEmployee).toBe('function');
      expect(typeof result.current.searchContractor).toBe('function');
      expect(typeof result.current.addContractor).toBe('function');
      expect(typeof result.current.refreshData).toBe('function');
      expect(typeof result.current.filterStaff).toBe('function');
    });
  });

  describe('Employee Management', () => {
    it('should invite employee successfully', async () => {
      const { result } = renderHook(() => useStaff());

      const employeeData = {
        firstName: 'Test',
        lastName: 'Employee',
        email: 'test@example.com',
        phone: '+61 400 000 000',
        role: 'Mover',
        team: 'Operations',
        hourlyRate: 25,
      };

      await act(async () => {
        const success = await result.current.inviteEmployee(employeeData);
        expect(success).toBe(true);
      });

      expect(result.current.error).toBe(null);
      expect(result.current.employees.length).toBeGreaterThan(0);
      
      const invitedEmployee = result.current.employees.find(
        (emp: Employee) => emp.email === 'test@example.com'
      );
      expect(invitedEmployee).toBeDefined();
    });

    it('should handle employee invitation error', async () => {
      const { result } = renderHook(() => useStaff());

      const invalidData = {
        firstName: '',
        lastName: '',
        email: 'invalid-email',
        phone: '',
        role: '',
        team: '',
        hourlyRate: -1,
      };

      await act(async () => {
        const success = await result.current.inviteEmployee(invalidData);
        expect(success).toBe(false);
      });

      expect(result.current.error).not.toBe(null);
    });

    it('should prevent duplicate employee emails', async () => {
      const { result } = renderHook(() => useStaff());

      const employeeData = {
        firstName: 'John',
        lastName: 'Doe',
        email: 'john@example.com',
        phone: '+61 400 000 000',
        role: 'Mover',
        team: 'Operations',
        hourlyRate: 25,
      };

      // Première invitation
      await act(async () => {
        await result.current.inviteEmployee(employeeData);
      });

      // Tentative de duplication
      await act(async () => {
        const success = await result.current.inviteEmployee(employeeData);
        expect(success).toBe(false);
      });

      expect(result.current.error).toContain('déjà invité');
    });
  });

  describe('Contractor Management', () => {
    it('should search contractors successfully', async () => {
      const { result } = renderHook(() => useStaff());

      await act(async () => {
        const contractors = await result.current.searchContractor('test query');
        expect(Array.isArray(contractors)).toBe(true);
      });

      expect(result.current.error).toBe(null);
    });

    it('should add contractor successfully', async () => {
      const { result } = renderHook(() => useStaff());

      const contractorToAdd: Omit<Contractor, 'id'> = {
        type: 'contractor',
        firstName: 'Test',
        lastName: 'Contractor',
        email: 'contractor@example.com',
        phone: '+61 400 000 003',
        role: 'Specialist',
        team: 'Operations',
        abn: '11 111 111 111',
        rate: 55,
        rateType: 'hourly',
        contractStatus: 'standard',
        isVerified: false,
        startDate: '2024-01-01',
        status: 'active',
      };

      await act(async () => {
        const success = await result.current.addContractor(contractorToAdd);
        expect(success).toBe(true);
      });

      expect(result.current.error).toBe(null);
      expect(result.current.contractors.length).toBeGreaterThan(0);
      
      const addedContractor = result.current.contractors.find(
        (c: Contractor) => c.id === contractorToAdd.id
      );
      expect(addedContractor).toBeDefined();
    });

    it('should handle contractor search error', async () => {
      const { result } = renderHook(() => useStaff());

      await act(async () => {
        const contractors = await result.current.searchContractor('');
        expect(contractors).toEqual([]);
      });

      expect(result.current.error).not.toBe(null);
    });
  });

  describe('Data Aggregation & Statistics', () => {
    it('should calculate statistics correctly', async () => {
      const { result } = renderHook(() => useStaff());

      // Ajouter des données de test
      await act(async () => {
        await result.current.inviteEmployee({
          firstName: 'John',
          lastName: 'Doe',
          email: 'john1@example.com',
          phone: '+61 400 000 000',
          role: 'Lead',
          team: 'Operations',
          hourlyRate: 35,
        });

        await result.current.addContractor({
          type: 'contractor',
          firstName: 'Mike',
          lastName: 'Johnson',
          email: 'mike1@contractor.com',
          phone: '+61 400 000 002',
          role: 'Specialist',
          team: 'Operations',
          abn: '12 345 678 901',
          rate: 50,
          rateType: 'hourly',
          contractStatus: 'preferred',
          isVerified: true,
          startDate: '2024-01-01',
          status: 'active',
        });
      });

      expect(result.current.totalEmployees).toBeGreaterThanOrEqual(1);
      expect(result.current.totalContractors).toBeGreaterThanOrEqual(1);
      expect(result.current.totalActive).toBeGreaterThanOrEqual(2);
      expect(result.current.staff.length).toBe(
        result.current.employees.length + result.current.contractors.length
      );
    });

    it('should provide correct data aggregations', () => {
      const { result } = renderHook(() => useStaff());

      // Mock some data
      const employees = mockEmployees;
      const contractors = mockContractors;

      employees.forEach((emp: Employee) => {
        expect(emp.type).toBe('employee');
        expect(emp.hourlyRate).toBeGreaterThan(0);
      });

      contractors.forEach((contractor: Contractor) => {
        expect(contractor.type).toBe('contractor');
        expect(contractor.rate).toBeGreaterThan(0);
      });

      // Test filtering
      const activeEmployees = employees.filter(
        (emp: Employee) => emp.invitationStatus === 'completed' && emp.status === 'active'
      );
      const verifiedContractors = contractors.filter(
        (contractor: Contractor) => contractor.isVerified
      );

      expect(activeEmployees.length).toBeLessThanOrEqual(employees.length);
      expect(verifiedContractors.length).toBeLessThanOrEqual(contractors.length);
    });
  });

  describe('Filtering & Search', () => {
    it('should filter staff by type', async () => {
      const { result } = renderHook(() => useStaff());

      await act(async () => {
        const employeesOnly = await result.current.filterStaff({
          type: 'employee',
          team: '',
          status: 'all',
        });
        expect(Array.isArray(employeesOnly)).toBe(true);

        const contractorsOnly = await result.current.filterStaff({
          type: 'contractor',
          team: '',
          status: 'all',
        });
        expect(Array.isArray(contractorsOnly)).toBe(true);
      });
    });

    it('should filter staff by team', async () => {
      const { result } = renderHook(() => useStaff());

      await act(async () => {
        const operationsTeam = await result.current.filterStaff({
          type: 'all',
          team: 'Operations',
          status: 'all',
        });
        expect(Array.isArray(operationsTeam)).toBe(true);
      });
    });

    it('should filter staff by status', async () => {
      const { result } = renderHook(() => useStaff());

      await act(async () => {
        const activeStaff = await result.current.filterStaff({
          type: 'all',
          team: '',
          status: 'active',
        });
        expect(Array.isArray(activeStaff)).toBe(true);
      });
    });
  });

  describe('Error Handling', () => {
    it('should handle network errors gracefully', async () => {
      const { result } = renderHook(() => useStaff());

      await act(async () => {
        // Simuler une erreur réseau
        const success = await result.current.inviteEmployee({
          firstName: 'Network',
          lastName: 'Error',
          email: 'error@network.com',
          phone: '+61 400 000 000',
          role: 'Test',
          team: 'Test',
          hourlyRate: 25,
        });
        
        // Le hook devrait gérer l'erreur gracieusement
        expect(typeof success).toBe('boolean');
      });
    });

    it('should clear errors when operations succeed', async () => {
      const { result } = renderHook(() => useStaff());

      // Provoquer une erreur d'abord
      await act(async () => {
        await result.current.inviteEmployee({
          firstName: '',
          lastName: '',
          email: 'invalid',
          phone: '',
          role: '',
          team: '',
          hourlyRate: -1,
        });
      });

      expect(result.current.error).not.toBe(null);

      // Puis une opération réussie
      await act(async () => {
        await result.current.inviteEmployee({
          firstName: 'Valid',
          lastName: 'User',
          email: 'valid@example.com',
          phone: '+61 400 000 000',
          role: 'Mover',
          team: 'Operations',
          hourlyRate: 25,
        });
      });

      expect(result.current.error).toBe(null);
    });
  });

  describe('Loading States', () => {
    it('should manage loading states correctly', async () => {
      const { result } = renderHook(() => useStaff());

      expect(result.current.isLoading).toBe(false);

      let invitePromise: Promise<boolean>;
      
      await act(async () => {
        invitePromise = result.current.inviteEmployee({
          firstName: 'Loading',
          lastName: 'Test',
          email: 'loading@example.com',
          phone: '+61 400 000 000',
          role: 'Tester',
          team: 'QA',
          hourlyRate: 30,
        });
        
        await invitePromise;
      });

      expect(result.current.isLoading).toBe(false);
    });

    it('should refresh data correctly', async () => {
      const { result } = renderHook(() => useStaff());

      await act(async () => {
        await result.current.refreshData();
      });

      expect(result.current.error).toBe(null);
      expect(Array.isArray(result.current.staff)).toBe(true);
      expect(Array.isArray(result.current.employees)).toBe(true);
      expect(Array.isArray(result.current.contractors)).toBe(true);
    });
  });
});